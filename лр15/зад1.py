import time#Импорт модуля time
from functools import wraps#Импорт функции wraps из модуля functools
def timeit(method):#Определение декоратора timeit, который принимает на вход метод
    @wraps(method)
    def timed(*args, **kw):#Декоратор timed оборачивает вызов метода и выводит время выполнения в миллисекундах
        ts = time.monotonic()#ts - сохраняем текущее время перед выполнением метода
        result = method(*args, **kw)#Вызов метода с переданными аргументами
        te = time.monotonic()#te - сохраняем текущее время после выполнения метода
        ms = (te - ts) * 1000#ms - рассчитываем разницу между начальным и конечным временем выполнения метода
        all_args = ', '.join(tuple(f'{a!r}' for a in args)#allargs - создаем строку из переданных аргументов
                             + tuple(f'{k}={v!r}' for k, v in kw.items()))
        print(f'{method.__name__}({all_args}): {ms:2.2f} ms')# Выводим имя метода, переданные аргументы и время выполнения метода
        return result#Возвращаем результат выполнения метода
    return timed
# использование:
@timeit
def slow_func(x, y, sleep):#Определение функции slow_func, которая будет обернута декоратором timeit
    time.sleep(sleep)#time.sleep(sleep) - задержка на указанное количество секунд
    return x + y#Вернуть сумму аргументов x и y

slow_func(10, 20, sleep=2)
#Функция slow_func выполняет сложение двух чисел x и y.
# Она также принимает параметр sleep, который указывает время в секундах, на которое функция будет заснуть с использованием функции time.sleep, прежде чем выполнить сложение.
# Функция slow_func декорирована с помощью декоратора @timeit, который измеряет время выполнения функции и выводит его в миллисекундах.